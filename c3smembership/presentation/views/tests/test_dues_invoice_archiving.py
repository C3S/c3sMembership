# -*- coding: utf-8 -*-
"""
Test the c3smembership.presentation.views.dues_invoice_archiving package
"""

import unittest

import mock
from pyramid import testing
from webob.multidict import MultiDict

from c3smembership.presentation.views.dues_invoice_archiving import (
    batch_archive_pdf_invoices,
    background_archive_pdf_invoices,
    BackgroundArchivingControl,
    background_archiving,
    AlreadyStoppedError,
    AlreadyRunningError,
)


class TestDuesInvoiceArchiving(unittest.TestCase):
    """
    Test the dues_invoice_archiving package
    """

    def setUp(self):
        """
        Set up testing

        Initialize Pyramid testing, dummy request and repository mock
        """
        self.request = testing.DummyRequest()
        self.config = testing.setUp(request=self.request)
        self.config.registry.dues_invoice_archiving = mock.Mock()
        # configure two stats as the repository is requested twice on form
        # submits, before archiving and then again afterwards
        archiving_stats = [
            {
                'year': 2015,
                'total': 30,
                'archived': 10,
                'not_archived': 20,
            }
        ]
        self.config.registry.dues_invoice_archiving.get_archiving_stats \
            .side_effect = [archiving_stats, archiving_stats]
        self.config.registry.dues_invoice_archiving.get_configured_years \
            .side_effect = [[2015]]

    def tearDown(self):
        """
        Tear down the testing setup
        """
        testing.tearDown()

    def test_get(self):
        """
        Test a GET request to the view
        """
        result = batch_archive_pdf_invoices(self.request)
        self._validate_result(result, [])

    def test_post_all_invoices(self):
        """
        Test a POST request to the view generating all remaining invoices
        """
        self._configure_missing_invoices_generated(['invoice1', 'invoice2'])
        self._configure_post_request(2015, 1)

        result = batch_archive_pdf_invoices(self.request)
        self._validate_result(result, ['invoice1', 'invoice2'])
        self._validate_flash_message(
            'success',
            [u'Success', u'2 invoices', u'no more'])

    def test_post_some_invoices(self):
        """
        Test a POST request to the view generating some remaining invoices
        """
        self._configure_missing_invoices_generated(['invoice1'])
        self._configure_post_request(2015, 1)

        result = batch_archive_pdf_invoices(self.request)

        self._validate_result(result, ['invoice1'])
        self._validate_flash_message(
            'success',
            [u'Success', u'1 invoices', u'might be more'])

    def test_post_nothing_left(self):
        """
        Test a POST request to the view with no remaining invoices left
        """
        self._configure_missing_invoices_generated([])
        self._configure_post_request(2015, 1)

        result = batch_archive_pdf_invoices(self.request)

        self._validate_result(result, [])
        self._validate_flash_message('success', [u'were no invoices'])

    def test_post_error(self):
        """
        Test a POST request to the view with an error occurring while invoice
        generation
        """
        self._configure_missing_invoices_generated()
        self._configure_post_request(2015, 1)

        result = batch_archive_pdf_invoices(self.request)

        self._validate_result(result, None)
        self._validate_flash_message('danger', [u'error'])

    def test_post_count_zero(self):
        """
        Test a POST request to the view with count zero
        """
        self._configure_missing_invoices_generated()
        self._configure_post_request(2015, 0)

        result = batch_archive_pdf_invoices(self.request)

        self._validate_result(result, [])
        self.assertTrue(
            u'There was a problem with your submission' in result['form'])

    def test_post_count_negative(self):
        """
        Test a POST request to the view with count negative
        """
        self._configure_missing_invoices_generated()
        self._configure_post_request(2015, -10)

        result = batch_archive_pdf_invoices(self.request)

        self._validate_result(result, [])
        self.assertTrue(
            u'There was a problem with your submission' in result['form'])

    def _configure_missing_invoices_generated(self, invoices=None):
        """
        Configure the invoices to be generated by the business layer

        Args:
            invoices: Array. Invoices to be by the business layer as
                successfully generated.
        """
        self.config.registry.dues_invoice_archiving \
            .generate_missing_invoice_pdfs.side_effect = [invoices]

    def _configure_post_request(self, year, count):
        """
        Configure the request for a POST method with year and count

        Args:
            year: Integer. The year to be passed via the POST request.
            count: Integer. The count to be passed via the POST request.
        """
        self.request.method = 'POST'
        self.request.POST = MultiDict()
        self.request.POST.add('__formid__', u'form')
        self.request.POST.add('__start__', u'archive_invoices:mapping')
        self.request.POST.add('year', unicode(year))
        self.request.POST.add('count', unicode(count))
        self.request.POST.add('__end__', u'archive_invoices:mapping')

    def _validate_flash_message(self, queue, message_parts):
        """
        Validate that all message parts are included in the flash message of
        the specified queue

        Args:
            queue: String. The name of the flash message queue to be validated.
            message_parts: Array of String. Message parts which must be found
                in the flash message.
        """
        flash_message = self.request.session.pop_flash(queue)[0]
        for message_part in message_parts:
            self.assertTrue(message_part in flash_message)

    def _validate_result(self, result, expected_invoices):
        """
        Validate the request result

        Validate that:

        - all components generated_invoices, archiving_stats and form are part
          of the result.
        - archiving_stats are correct
        - generated_invoices are as specified

        Args:
            result: The request result to be validated
            expected_invoices: The invoices expected to be generated with the
                request
        """
        self.assertTrue('generated_invoices' in result)
        self.assertTrue('archiving_stats' in result)
        self.assertTrue('form' in result)
        self.assertTrue('archiving_stats_sums' in result)
        self.assertTrue('background_archiving_active' in result)
        self.assertTrue('background_archiving_count' in result)
        self.assertTrue('background_archiving_total' in result)
        self.assertTrue('background_archiving_error' in result)

        self.assertEqual(len(result['archiving_stats']), 1)
        self.assertEqual(result['archiving_stats'][0]['year'], 2015)
        self.assertEqual(result['archiving_stats'][0]['total'], 30)
        self.assertEqual(result['archiving_stats'][0]['archived'], 10)
        self.assertEqual(result['archiving_stats'][0]['not_archived'], 20)
        self.assertEqual(result['generated_invoices'], expected_invoices)



class TestBackgroundArchiving(unittest.TestCase):
    """
    Test background archiving
    """

    def setUp(self):
        """
        Set up testing

        Initialize Pyramid testing, dummy request and repository mock
        """
        self.request = testing.DummyRequest()
        self.config = testing.setUp(request=self.request)
        self.config.add_route(
            'batch_archive_pdf_invoices', '/batch_archive_pdf_invoices')
        # configure two stats as the repository is requested twice on form
        # submits, before archiving and then again afterwards
        archiving_stats = [
            {
                'year': 2015,
                'total': 30,
                'archived': 10,
                'not_archived': 20,
            }
        ]
        self.dues_invoice_archiving = mock.Mock()
        self.config.registry.dues_invoice_archiving = self.dues_invoice_archiving
        self.dues_invoice_archiving.get_archiving_stats \
            .side_effect = [archiving_stats, archiving_stats]
        self.dues_invoice_archiving.get_configured_years \
            .side_effect = [[2015]]
        self.dues_invoice_archiving.generate_missing_invoice_pdfs \
            .side_effect = [['test.pdf'], []]

        self.background_archiving_control = mock.Mock()
        background_archive_pdf_invoices.background_archiving_control = \
            self.background_archiving_control

        self.logger = mock.Mock()
        background_archive_pdf_invoices.logger = self.logger

    def tearDown(self):
        """
        Tear down the testing setup
        """
        testing.tearDown()

    def test_background_archive_pdf_invoices(self):
        """
        Test starting background archiving

        1. Test starting
        2. Test already running
        """
        # 1. Test starting
        self.background_archiving_control.is_running.side_effect = [
            False, True]
        self.background_archiving_control.start.side_effect = [False]

        result = background_archive_pdf_invoices(self.request)

        self.logger.info.assert_called_with('Starting background invoice archiving')
        self.assertEqual(result.status_code, 302)

        # 2. Test already running
        self.background_archiving_control.is_running.side_effect = [True]

        result = background_archive_pdf_invoices(self.request)

        self.logger.info.assert_called_with('Invoice archiving already running')
        self.assertEqual(result.status_code, 302)

    def test_background_archiving(self):
        """
        Test background archiving

        1. Normal call
        2. Exception handling
        """
        # 1. Normal call
        background_archiving.logger = mock.Mock()

        background_archiving(
            self.dues_invoice_archiving, self.background_archiving_control)

        self.dues_invoice_archiving.get_archiving_stats.assert_called_with()
        self.dues_invoice_archiving.generate_missing_invoice_pdfs \
            .assert_called_with(2015, 1)
        self.background_archiving_control.increment_count.assert_called_with()
        background_archiving.logger.info.assert_has_calls([
            mock.call('Generated %d invoice: %s', 1, 'test.pdf'),
            mock.call('Finished background invoice archiving')])

        # 2. Exception handling
        self.dues_invoice_archiving.get_archiving_stats.side_effect = [Exception()]

        background_archiving(
            self.dues_invoice_archiving, self.background_archiving_control)

        background_archiving.logger.exception.assert_called_with(
            'An error occured during background invoice archiving')


class TestBackgroundArchivingControl(unittest.TestCase):
    """
    Test the BackgroundArchivingControl class
    """

    def test(self):
        """
        Test BackgroundArchivingControl

        1. Initial, not running
        2. Start
        3. Increment count
        4. Set error
        5. Stop
        6. Error when start and already started
        7. Error when stop and already stopped
        """
        # 1. Initial, not running
        self.assertEqual(BackgroundArchivingControl.is_running(), False)
        self.assertEqual(BackgroundArchivingControl.get_count(), 0)
        self.assertEqual(BackgroundArchivingControl.get_total(), 0)
        self.assertEqual(BackgroundArchivingControl.has_error(), False)

        # 2. Start
        BackgroundArchivingControl.start(10)
        self.assertEqual(BackgroundArchivingControl.is_running(), True)
        self.assertEqual(BackgroundArchivingControl.get_total(), 10)
        self.assertEqual(BackgroundArchivingControl.get_count(), 0)
        self.assertEqual(BackgroundArchivingControl.has_error(), False)

        # 3. Increment count
        BackgroundArchivingControl.increment_count()
        self.assertEqual(BackgroundArchivingControl.is_running(), True)
        self.assertEqual(BackgroundArchivingControl.get_total(), 10)
        self.assertEqual(BackgroundArchivingControl.get_count(), 1)
        self.assertEqual(BackgroundArchivingControl.has_error(), False)

        # 4. Set error
        BackgroundArchivingControl.set_error()
        self.assertEqual(BackgroundArchivingControl.is_running(), True)
        self.assertEqual(BackgroundArchivingControl.get_total(), 10)
        self.assertEqual(BackgroundArchivingControl.get_count(), 1)
        self.assertEqual(BackgroundArchivingControl.has_error(), True)

        # 5. Stop
        BackgroundArchivingControl.stop()
        self.assertEqual(BackgroundArchivingControl.is_running(), False)
        self.assertEqual(BackgroundArchivingControl.get_total(), 10)
        self.assertEqual(BackgroundArchivingControl.get_count(), 1)
        self.assertEqual(BackgroundArchivingControl.has_error(), True)

        # 6. Error when start and already started
        BackgroundArchivingControl.start(10)
        with self.assertRaises(AlreadyRunningError):
            BackgroundArchivingControl.start(10)

        # 7. Error when stop and already stopped
        BackgroundArchivingControl.stop()
        with self.assertRaises(AlreadyStoppedError):
            BackgroundArchivingControl.stop()
